//#region ../../node_modules/.pnpm/camelcase@9.0.0/node_modules/camelcase/index.js
const UPPERCASE = /[\p{Lu}]/u;
const LOWERCASE = /[\p{Ll}]/u;
const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/u;
const SEPARATORS = /[_.\- ]+/;
const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
const LEADING_SEPARATORS = /* @__PURE__ */ new RegExp("^" + SEPARATORS.source);
const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
const NUMBERS_AND_IDENTIFIER = new RegExp(String.raw`\d+` + IDENTIFIER.source, "gu");
const preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase$1) => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;
	let isLastLastCharPreserved = false;
	for (let index = 0; index < string.length; index++) {
		const character = string[index];
		isLastLastCharPreserved = index > 2 ? string[index - 3] === "-" : true;
		if (isLastCharLower && UPPERCASE.test(character)) {
			string = string.slice(0, index) + "-" + string.slice(index);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			index++;
		} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase$1)) {
			string = string.slice(0, index - 1) + "-" + string.slice(index - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
		}
	}
	return string;
};
const preserveConsecutiveUppercase = (input, toLowerCase) => input.replace(LEADING_CAPITAL, (match) => toLowerCase(match));
const processWithCasePreservation = (input, toLowerCase, preserveConsecutiveUppercase$1) => {
	let result = "";
	let previousWasNumber = false;
	let previousWasUppercase = false;
	const characters = [...input];
	for (let index = 0; index < characters.length; index++) {
		const character = characters[index];
		const isUpperCase = UPPERCASE.test(character);
		const nextCharIsUpperCase = index + 1 < characters.length && UPPERCASE.test(characters[index + 1]);
		if (previousWasNumber && /[\p{Alpha}]/u.test(character)) {
			result += character;
			previousWasNumber = false;
			previousWasUppercase = isUpperCase;
		} else if (preserveConsecutiveUppercase$1 && isUpperCase && (previousWasUppercase || nextCharIsUpperCase)) {
			result += character;
			previousWasUppercase = true;
		} else if (/\d/.test(character)) {
			result += character;
			previousWasNumber = true;
			previousWasUppercase = false;
		} else if (SEPARATORS.test(character)) {
			result += character;
			previousWasUppercase = false;
		} else {
			result += toLowerCase(character);
			previousWasNumber = false;
			previousWasUppercase = false;
		}
	}
	return result;
};
/**
Core post-processing:
- Collapses separators and uppercases the following identifier character.
- Optionally uppercases the identifier following a numeric sequence.

Two-pass strategy prevents conflicts:
1. NUMBERS_AND_IDENTIFIER: handles digit-to-letter transitions
2. SEPARATORS_AND_IDENTIFIER: handles separator-to-identifier transitions

Example: "b2b_registration" with capitalizeAfterNumber: true
- Pass 1: "2b" matches, next char is "_" (separator), so don't capitalize → "b2b_registration"
- Pass 2: "_r" matches, replace with "R" → "b2bRegistration"
*/
const postProcess = (input, toUpperCase, { capitalizeAfterNumber }) => {
	const transformNumericIdentifier = capitalizeAfterNumber ? (match, identifier, offset, string) => {
		const nextCharacter = string.charAt(offset + match.length);
		if (SEPARATORS.test(nextCharacter)) return match;
		return identifier ? match.slice(0, -identifier.length) + toUpperCase(identifier) : match;
	} : (match) => match;
	return input.replaceAll(NUMBERS_AND_IDENTIFIER, transformNumericIdentifier).replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier));
};
function camelCase(input, options) {
	if (!(typeof input === "string" || Array.isArray(input))) throw new TypeError("Expected the input to be `string | string[]`");
	options = {
		pascalCase: false,
		preserveConsecutiveUppercase: false,
		capitalizeAfterNumber: true,
		...options
	};
	if (Array.isArray(input)) input = input.map((element) => element.trim()).filter((element) => element.length > 0).join("-");
	else input = input.trim();
	if (input.length === 0) return "";
	const leadingPrefix = input.match(/^[_$]*/)[0];
	input = input.slice(leadingPrefix.length);
	if (input.length === 0) return leadingPrefix;
	const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
	const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
	if (input.length === 1) {
		if (SEPARATORS.test(input)) return leadingPrefix;
		return leadingPrefix + (options.pascalCase ? toUpperCase(input) : toLowerCase(input));
	}
	const hasUpperCase = input !== toLowerCase(input);
	if (hasUpperCase) input = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);
	input = input.replace(LEADING_SEPARATORS, "");
	if (options.capitalizeAfterNumber) input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);
	else input = processWithCasePreservation(input, toLowerCase, options.preserveConsecutiveUppercase);
	if (options.pascalCase && input.length > 0) input = toUpperCase(input[0]) + input.slice(1);
	return leadingPrefix + postProcess(input, toUpperCase, options);
}

//#endregion
export { camelCase };
//# sourceMappingURL=index.js.map