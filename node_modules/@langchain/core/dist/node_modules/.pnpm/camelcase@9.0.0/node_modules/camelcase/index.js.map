{"version":3,"file":"index.js","names":["preserveConsecutiveUppercase"],"sources":["../../../../../../../../node_modules/.pnpm/camelcase@9.0.0/node_modules/camelcase/index.js"],"sourcesContent":["const UPPERCASE = /[\\p{Lu}]/u;\nconst LOWERCASE = /[\\p{Ll}]/u;\nconst LEADING_CAPITAL = /^[\\p{Lu}](?![\\p{Lu}])/u;\nconst SEPARATORS = /[_.\\- ]+/;\n\n// The |$ alternative allows matching at end-of-string, capturing empty string\n// This enables NUMBERS_AND_IDENTIFIER to match digits at string end (e.g., \"test123\")\nconst IDENTIFIER = /([\\p{Alpha}\\p{N}_]|$)/u;\n\nconst LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);\nconst SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');\nconst NUMBERS_AND_IDENTIFIER = new RegExp(String.raw`\\d+` + IDENTIFIER.source, 'gu');\n\nconst preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase) => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\tlet isLastLastCharPreserved = false;\n\n\tfor (let index = 0; index < string.length; index++) {\n\t\tconst character = string[index];\n\n\t\t// Was the character 3 positions back inserted as a separator?\n\t\t// Prevents excessive separators by checking if we recently inserted one\n\t\t// index - 3 accounts for: current character, inserted separator, previous character\n\t\t// Default true for early positions activates the preserveConsecutiveUppercase guard\n\t\tisLastLastCharPreserved = index > 2 ? string[index - 3] === '-' : true;\n\n\t\tif (isLastCharLower && UPPERCASE.test(character)) {\n\t\t\t// FooBar → Foo-Bar (insert separator before uppercase)\n\t\t\tstring = string.slice(0, index) + '-' + string.slice(index);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\tindex++;\n\t\t} else if (\n\t\t\tisLastCharUpper\n\t\t\t&& isLastLastCharUpper\n\t\t\t&& LOWERCASE.test(character)\n\t\t\t&& (!isLastLastCharPreserved || preserveConsecutiveUppercase)\n\t\t) {\n\t\t\t// FOOBar → FOO-Bar\n\t\t\tstring = string.slice(0, index - 1) + '-' + string.slice(index - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower\n\t\t\t\t= toLowerCase(character) === character\n\t\t\t\t\t&& toUpperCase(character) !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper\n\t\t\t\t= toUpperCase(character) === character\n\t\t\t\t\t&& toLowerCase(character) !== character;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst preserveConsecutiveUppercase = (input, toLowerCase) => input.replace(LEADING_CAPITAL, match => toLowerCase(match));\n\nconst processWithCasePreservation = (input, toLowerCase, preserveConsecutiveUppercase) => {\n\tlet result = '';\n\tlet previousWasNumber = false;\n\tlet previousWasUppercase = false;\n\n\t// Convert input to array for lookahead capability\n\tconst characters = [...input];\n\n\tfor (let index = 0; index < characters.length; index++) {\n\t\tconst character = characters[index];\n\t\tconst isUpperCase = UPPERCASE.test(character);\n\t\tconst nextCharIsUpperCase = index + 1 < characters.length && UPPERCASE.test(characters[index + 1]);\n\n\t\tif (previousWasNumber && /[\\p{Alpha}]/u.test(character)) {\n\t\t\t// Letter after number - preserve original case\n\t\t\tresult += character;\n\t\t\tpreviousWasNumber = false;\n\t\t\tpreviousWasUppercase = isUpperCase;\n\t\t} else if (preserveConsecutiveUppercase && isUpperCase && (previousWasUppercase || nextCharIsUpperCase)) {\n\t\t\t// Part of consecutive uppercase sequence when preserveConsecutiveUppercase is true - keep it\n\t\t\tresult += character;\n\t\t\tpreviousWasUppercase = true;\n\t\t} else if (/\\d/.test(character)) {\n\t\t\t// Number - keep as-is and track it\n\t\t\tresult += character;\n\t\t\tpreviousWasNumber = true;\n\t\t\tpreviousWasUppercase = false;\n\t\t} else if (SEPARATORS.test(character)) {\n\t\t\t// Separator - keep as-is and maintain previousWasNumber state\n\t\t\tresult += character;\n\t\t\tpreviousWasUppercase = false;\n\t\t} else {\n\t\t\t// Regular character - lowercase it\n\t\t\tresult += toLowerCase(character);\n\t\t\tpreviousWasNumber = false;\n\t\t\tpreviousWasUppercase = false;\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\nCore post-processing:\n- Collapses separators and uppercases the following identifier character.\n- Optionally uppercases the identifier following a numeric sequence.\n\nTwo-pass strategy prevents conflicts:\n1. NUMBERS_AND_IDENTIFIER: handles digit-to-letter transitions\n2. SEPARATORS_AND_IDENTIFIER: handles separator-to-identifier transitions\n\nExample: \"b2b_registration\" with capitalizeAfterNumber: true\n- Pass 1: \"2b\" matches, next char is \"_\" (separator), so don't capitalize → \"b2b_registration\"\n- Pass 2: \"_r\" matches, replace with \"R\" → \"b2bRegistration\"\n*/\nconst postProcess = (input, toUpperCase, {capitalizeAfterNumber}) => {\n\tconst transformNumericIdentifier = capitalizeAfterNumber\n\t\t? (match, identifier, offset, string) => {\n\t\t\tconst nextCharacter = string.charAt(offset + match.length);\n\n\t\t\t// If the numeric+identifier run is immediately followed by a separator,\n\t\t\t// treat it as a continued token and do not force a new word.\n\t\t\tif (SEPARATORS.test(nextCharacter)) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\t// Only uppercase the identifier part (not the digits) for efficiency\n\t\t\treturn identifier ? match.slice(0, -identifier.length) + toUpperCase(identifier) : match;\n\t\t}\n\t\t// When false: numbers do not create a word boundary.\n\t\t: match => match;\n\n\treturn input\n\t\t.replaceAll(NUMBERS_AND_IDENTIFIER, transformNumericIdentifier)\n\t\t.replaceAll(\n\t\t\tSEPARATORS_AND_IDENTIFIER,\n\t\t\t(_, identifier) => toUpperCase(identifier),\n\t\t);\n};\n\nexport default function camelCase(input, options) {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\n\toptions = {\n\t\tpascalCase: false,\n\t\tpreserveConsecutiveUppercase: false,\n\t\tcapitalizeAfterNumber: true,\n\t\t...options,\n\t};\n\n\tif (Array.isArray(input)) {\n\t\tinput = input\n\t\t\t.map(element => element.trim())\n\t\t\t.filter(element => element.length > 0)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\n\t// Preserve leading _ and $ as they have semantic meaning\n\tconst leadingPrefix = input.match(/^[_$]*/)[0];\n\tinput = input.slice(leadingPrefix.length);\n\n\tif (input.length === 0) {\n\t\treturn leadingPrefix;\n\t}\n\n\tconst toLowerCase = options.locale === false\n\t\t? string => string.toLowerCase()\n\t\t: string => string.toLocaleLowerCase(options.locale);\n\n\tconst toUpperCase = options.locale === false\n\t\t? string => string.toUpperCase()\n\t\t: string => string.toLocaleUpperCase(options.locale);\n\n\tif (input.length === 1) {\n\t\tif (SEPARATORS.test(input)) {\n\t\t\treturn leadingPrefix;\n\t\t}\n\n\t\treturn leadingPrefix + (options.pascalCase\n\t\t\t? toUpperCase(input)\n\t\t\t: toLowerCase(input));\n\t}\n\n\tconst hasUpperCase = input !== toLowerCase(input);\n\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(\n\t\t\tinput,\n\t\t\ttoLowerCase,\n\t\t\ttoUpperCase,\n\t\t\toptions.preserveConsecutiveUppercase,\n\t\t);\n\t}\n\n\t// Strip leading separators eagerly so they do not affect word detection\n\tinput = input.replace(LEADING_SEPARATORS, '');\n\n\t// Normalize base casing while preserving intended consecutive uppers\n\tif (options.capitalizeAfterNumber) {\n\t\t// Standard behavior - lowercase everything (or preserve consecutive uppercase)\n\t\tinput = options.preserveConsecutiveUppercase\n\t\t\t? preserveConsecutiveUppercase(input, toLowerCase)\n\t\t\t: toLowerCase(input);\n\t} else {\n\t\t// Preserve case after numbers (processWithCasePreservation handles preserveConsecutiveUppercase internally)\n\t\tinput = processWithCasePreservation(input, toLowerCase, options.preserveConsecutiveUppercase);\n\t}\n\n\tif (options.pascalCase && input.length > 0) {\n\t\tinput = toUpperCase(input[0]) + input.slice(1);\n\t}\n\n\treturn leadingPrefix + postProcess(input, toUpperCase, options);\n}\n"],"x_google_ignoreList":[0],"mappings":"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"}